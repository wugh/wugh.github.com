<!DOCTYPE html>
<html lang="zh-cn" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#">
    <head>
	<meta charset="utf-8">
	
	<meta name="description" content="">
    <meta name="author" content="Guohua Wu">
	<meta name="robots" content="index,follow">


	<!-- OpenGraph -->
	<meta property="og:property" content="zh-cn">
	<meta property="og:image" content="/assets/images/favicons/apple-touch-icon-180x180.png">
	<meta property="og:title" content="Life in a Nutshell articles in Machine Learning category">
	<meta property="og:type" content="website">
	<meta property="og:description" content="">	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Life in a Nutshell articles in Machine Learning category</title>
	<script type="text/javascript" src="https://wugh.github.io/theme/js/jquery-1.9.1.js"></script>
	<script type="text/javascript" src="https://wugh.github.io/theme/js/bootstrap.js"></script>

	<!-- Bootstrap CSS  -->
	<link rel="stylesheet" href="https://wugh.github.io/theme/css/bootstrap.css"/>
	<link rel="stylesheet" href="https://wugh.github.io/theme/css/responsive.css"/>
	
	<!-- Generated favicons markup -->
	<link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
	<link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="/images/favicons/android-icon-192x192.png" sizes="192x192">
	<link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
	<link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
	<link rel="manifest" href="/images/favicons/manifest.json">
	<link rel="shortcut icon" href="/images/favicons/favicon.ico">
	<meta name="msapplication-TileColor" content="#2b5797">
	<meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
	<meta name="msapplication-config" content="/images/favicons/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
	<!-- LESS generated css for Nuja theme -->
	<link rel="stylesheet" href="https://wugh.github.io/theme/css/NujaStructure.css"/>
	<!-- Highlight -->
	<link rel="stylesheet" href="https://wugh.github.io/theme/css/pygment.css"/>

	<link href="http://fonts.useso.com/css?family=Droid+Serif" rel="stylesheet" type="text/css">
	<link href='http://fonts.useso.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
	<link href='http://fonts.useso.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>
	<link href='http://fonts.useso.com/css?family=Noto+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
	<link href='http://fonts.useso.com/css?family=Vollkorn' rel='stylesheet' type='text/css'>
	<!--[if IE]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>



	<!-- setup feeds and third-party services -->
	<link href="https://wugh.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Life in a Nutshell Atom Feed" />
	<!-- to clean up later for the new theme -->
	<script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-968141-17', 'auto');
ga('send', 'pageview');

	</script>
	<meta name="google-site-verification" content="4TETrzpAoVPu2-VrTpOxQJFmmynS9VzPq_boE45VKa8" />
	<meta name="msvalidate.01" content="E2790C576E7623BE2F59AC965B48361D" />
    </head>
    <body>

	<div class="container">
	    <div class="header-container">
		<header>
		    <a href="https://wugh.github.io/">
			<h4>Life in a Nutshell 		    </a>

		    <nav>
			<ul>
			    <li><a href="https://wugh.github.io/">Home</a></li>
			    <li><a href="https://wugh.github.io/pages/about-me.html">About&nbsp;Me</a></li>

			    <li><a href="/archives.html">Archives</a></li>

			</ul>
		    </nav>
		</header>


	    </div>
	    <div class="clearfix"></div>
<div class="row">
    <div class="span12 alpha">
	<h3>You are now browsing through `Machine Learning` articles</h3>
    </div>
</div>
<div class="clearfix"></div>
	    <div class="row">
		<div class="span9">

		    <div class="span10">


<div class="row">
    <div class="span1 metadata alpha">
	<aside>
	    <div class="entry-date">
		<div class="month-day">
		    <time pubdate datetime="2014-11-14T00:00:00+08:00" title="Nov 14, 14">
			Nov.<span class="day">14</span>
			<div class="year">14</div>
		    </time>
		</div>

	    </div>

	</aside> 

    </div>
    <div class="span7">
	<div class="entry-container ">

	    <article  class="entry hentry" >
		<header>
		    <a href="/posts/2014/11/maxent/" rel="bookmark" title="permalink for 最大熵" ><h2 class="entry-title">最大熵</h2></a>
		    <div class="author-details vcard">

			by <a  class="url fn" href="/author/guohua-wu.html">Guohua Wu</a>  file under <a href="/category/machine-learning.html">Machine Learning</a> with tags 			<a href="https://wugh.github.io/tag/maxent.html" title="Browse tag: MaxEnt" rel="tag">MaxEnt</a>		    </div>
		</header>
		<div class="entry-content">
		<hr />
<h3>最大熵原理</h3>
<p>最大熵原理指的是当我们在估计概率分布的时候，这个概率分布符合已知信息的约束并且&nbsp;该分布是最均匀的。从熵的角度考虑就是要让这个分布符合约束并且熵最大。</p>
<blockquote>
<p>The principle of maximum entropy states that, subject to precisely stated
prior data (such as a proposition that expresses testable information), the
probability distribution which best represents the current state of knowledge
is the one with largest&nbsp;entropy.</p>
</blockquote>
<p>现在考虑一个文本分类的例子，假设我们有4个类别的文本分别是：economics、
sports、politics和art。因为文本只能被分成4个类别，假设现在没有额外的信息，&nbsp;那么约束只有以下的1个
</p>
<div class="math">$$p(economics)+p(sports)+p(politics)+p(art)=1$$</div>
<p>
那么我们希望得到得概率分布尽量均匀，就会得到下面结果
</p>
<div class="math">$$p(economics)=p(sports)=p(politics)=p(art)=0.25$$</div>
<p>
现在假设我们有一个先验信息是60%的文档是economics或者sports类别的，那么我们的&nbsp;概率分布就会有以下两个约束
</p>
<div class="math">$$p(economics)+p(sports)=0.6$$</div>
<div class="math">$$p(economics)+p(sports)+p(politics)+p(art)=1$$</div>
<p>
考虑以上两个约束又希望使得我们的分布均匀，将会得到下面的结果
</p>
<div class="math">$$
\begin{align}
\notag
p(economics)&amp;=0.30\cr
\notag
p(sports)&amp;=0.30\cr
\notag
p(politics)&amp;=0.20\cr
\notag
p(art)&amp;=0.20 
\end{align}
$$</div>
<p>
但是随着对数据的观察，可能又会对引入其他约束。这时候需要解决两个问题，首先是如
何来定量描述分布的均匀；其次是如何在考虑约束的条件下使得分布均匀。最大熵的基本
思路就是选择一个与给定事实一致的模型（满足约束），并且要使得模型对未知事实不做&nbsp;假设（使得分布尽量均匀）。</p>
<h3>最大熵建模</h3>
<p>我们继续考虑上面提到的文本分类的例子，假设用最简单的<a href="http://en.wikipedia.org/wiki/Bag-of-words_model" title="Bag-of-words model">词袋模型</a>来表示文档，&nbsp;每个文档都可以表示成一个词频向量，例如下面的简单的例子</p>
<div class="highlight"><pre><span class="n">Doc1</span><span class="o">:</span> <span class="n">John</span> <span class="n">likes</span> <span class="n">to</span> <span class="n">watch</span> <span class="n">movies</span><span class="o">.</span> <span class="n">Mary</span> <span class="n">likes</span> <span class="n">movies</span> <span class="n">too</span><span class="o">.</span>
<span class="n">Doc2</span><span class="o">:</span> <span class="n">John</span> <span class="n">also</span> <span class="n">likes</span> <span class="n">to</span> <span class="n">watch</span> <span class="n">football</span> <span class="n">games</span><span class="o">.</span>
</pre></div>


<p>得到词表如下:</p>
<div class="highlight"><pre>{
    &quot;John&quot;: 1,
    &quot;likes&quot;: 2,
    &quot;to&quot;: 3,
    &quot;watch&quot;: 4,
    &quot;movies&quot;: 5,
    &quot;also&quot;: 6,
    &quot;football&quot;: 7,
    &quot;games&quot;: 8,
    &quot;Mary&quot;: 9,
    &quot;too&quot;: 10
}
</pre></div>


<p>所以可以把Doc1和Doc2表示成两个10维的向量，如下:</p>
<div class="highlight"><pre>Doc1: [1, 2, 1, 1, 2, 0, 0, 0, 1, 1]
Doc2: [1, 1, 1, 1, 0, 1, 1, 1, 0, 0]
</pre></div>


<p>我们把当个文档用<span class="math">\(x\)</span>表示，文档类别用<span class="math">\(y\)</span>表示，根据上面的描述<span class="math">\(y\)</span>会有4个类别，跟
<a href="http://en.wikipedia.org/wiki/Logistic_regression" title="Logistic regression">Logistic Regression</a>类似，我们要建模一个判别模型<span class="math">\(p(y|x)\)</span>，即给定
一个文档<span class="math">\(x\)</span>，我们的模型可以得出这篇文档属于特定类别<span class="math">\(y\)</span>的概率。如果用<span class="math">\(\mathcal{P}\)</span>
表示所有的条件概率分布，那么<span class="math">\(p(y|x)\)</span>就是<span class="math">\(\mathcal{P}\)</span>中的一个元素。</p>
<h4>训练数据</h4>
<p>我们可以把的<span class="math">\(N\)</span>个训练数据表示成<span class="math">\(\\{(x_1,y_1),\cdots,(x_N,y_N)\\}\)</span>，且</p>
<ul>
<li><span class="math">\(x_i\in X\)</span>，其中<span class="math">\(X\)</span>表示所有的文档类别</li>
<li><span class="math">\(y_i\in Y\)</span>，其中<span class="math">\(Y\)</span>表示训练文档集合，每个文档用词频向量表示</li>
</ul>
<p>从训练数据样本中我们可以估计出一个经验的联合概率分布
</p>
<div class="math">$$\tilde{p}(x,y)=\frac{1}{N}\times \text{the number of times (x,y) appears}$$</div>
<h4>特征和约束</h4>
<p>最大熵建模的过程中特征函数（简称特征）主要是为了描述训练样本的统计量，例如&nbsp;建模的时候我们可能会考虑当ball这个词出现的时候，文档属于sports的概率是9/10。</p>
<p>为了描述ball出现时文档属于sports类别的事实我们引入特征函数（指示函数或者特征）
</p>
<div class="math">$$
f_{ball,sports} (x,y)=\begin{cases}
1 &amp; \text{if y=sports and ball appears in d} \cr
0 &amp; \text{otherwise}
\end{cases}
$$</div>
<p>
考虑经验分布<span class="math">\(\tilde{p}(x,y)\)</span>下<span class="math">\(f\)</span>的期望值，这个期望值就是我们关注的统计量（如
果对上面那个特征函数按照经验分布求期望，得到的东西就是当ball这个词出现的时候文&nbsp;档属于sports的概率），记为
</p>
<div class="math">$$
\begin{equation}
\tilde{p}(f)\equiv \sum_{x,y}{\tilde{p}(x,y)f(x,y)}
\end{equation}
\label{eq:empricalException}
$$</div>
<p>
其实样本的任何统计量都可以通过特征函数的期望值来表示。</p>
<p>如果我们发现了一些有用的统计量，我们就可以要求我们的模型也要遵循这个信息。我们
通过约束模型在特征函数<span class="math">\(f\)</span>上的期望值来遵循这个统计量，对于模型<span class="math">\(p(y|x)\)</span>特征函数
<span class="math">\(f\)</span>的期望值为
</p>
<div class="math">$$
\begin{equation}
p(f)\equiv \sum_{x,y}{\tilde{p}(x)p(y|x)f(x,y)}
\label{eq:modelException}
\end{equation}
$$</div>
<p>
其中<span class="math">\(\tilde{p}(x)\)</span>是训练样本中<span class="math">\(x\)</span>的经验分布。我们通过约束模型下特征函数的期望&nbsp;值等于样本中特征函数的期望值，如下所示
</p>
<div class="math">$$
\begin{equation}
p(f) = \tilde{p}(f)
\label{eq:constriant}
\end{equation}
$$</div>
<p>把前面的<span class="math">\(\ref{eq:empricalException}\)</span>，<span class="math">\(\ref{eq:modelException}\)</span>和
<span class="math">\(\ref{eq:constriant}\)</span>综合起来得意得到下面的约束</p>
<div class="math">$$
\sum_{x,y}{\tilde{p}(x)p(y|x)f(x,y)} = \sum_{x,y}{\tilde{p}(x,y)f(x,y)}
$$</div>
<p>这样我们只需要考虑那些满足<span class="math">\(\ref{eq:constriant}\)</span>的模型<span class="math">\(p(y|x)\)</span>。总的来说
我们用<span class="math">\(\tilde{p}(f)\)</span>表示样本数据中的统计特征，同时也要求我们的模型要表示出
这种特征（<span class="math">\(p(f)=\tilde{p}(f)\)</span>）。</p>
<p>假设我们现在有<span class="math">\(n\)</span>个我们认为很重要的特征函数<span class="math">\(f_i\)</span>，我们希望我们的模型遵循这些
特征在训练数据中所表现出的统计信息，那么<span class="math">\(p\)</span>就应该是<span class="math">\(\mathcal{P}\)</span>的一个子集
<span class="math">\(\mathcal{C}\)</span>，定义如下
</p>
<div class="math">$$
\begin{equation}
\mathcal{C} = \big\{p \in P \text{ | } p(f_i)=\tilde{p}(f_i) \text{ for i } \in \{1,2,\cdots,n\}\big\}
\label{eq:distsubset}
\end{equation}
$$</div>
<p>
下图解释为概率分布添加约束的过程，图中<span class="math">\(\mathcal{P}\)</span>表示一个在3个变量上的概率分
布，如果我们没有设置任何约束那么所有的概率分布都是可以的如图(a)所示；如果我们
添加一个线性约束<span class="math">\(\mathcal{C}_1\)</span>那么我们的概率分布只能落在图(b)中<span class="math">\(mathcal{C}_1\)</span>
这个线上面；此时如果再添加一个约束我们就能确定概率分布<span class="math">\(p\)</span>，如果第二个线性约束
<span class="math">\(\mathcal{C}_2\)</span>和<span class="math">\(\mathcal{C}_1\)</span>不冲突（有交点），那么这个交点就是我们要求的概
率分布<span class="math">\(p\)</span>，如图(c)所示；如果两个约束冲突，例如第一个约束要求第1点的概率是<span class="math">\(1/3\)</span>
而第二个约束是要求第3点的概率是<span class="math">\(3/4\)</span>，那么会得到图(d)的结果。由于我们的约束都
是从训练样本中抽取的，所以约束之间不可能冲突，而且我们的约束无法像图(c)一样唯
一确定<span class="math">\(p\)</span>，换句话说<span class="math">\(\mathcal{C}=\mathcal{C}_1\cap\mathcal{C}_2\cdots\cap\mathcal{C}_n\)</span>
所确定的模型有无数个。
<img alt="simplex" src="https://wugh.github.io/images/ML/simplex.png" title="simplex" /></p>
<p>在所有的模型<span class="math">\(p\in\mathcal{C}\)</span>中我们需要根据最大熵原理选择一个最均匀的，我们用
<a href="http://en.wikipedia.org/wiki/Conditional_entropy" title="条件熵">条件熵</a>量化度量条件分布<span class="math">\(p(y|x)\)</span>的均匀程度
</p>
<div class="math">$$
\begin{equation}
H(p)\equiv -\sum_{x,y}{\tilde{p}(x)p(y|x)\log{p(y|x)}}
\label{eq:conditionalentropy}
\end{equation}
$$</div>
<p>
条件熵的取值其下界是0（没有不确定性），上界是<span class="math">\(\log{|Y|}\)</span>（在所有<span class="math">\(y\)</span>的取值上均
匀分布）。我们的目的就是要从<span class="math">\(\mathcal{C}\)</span>里面找到一个模型<span class="math">\(p^*\in\mathcal{C}\)</span>使
得<span class="math">\(H(p)\)</span>最大，即
</p>
<div class="math">$$
\begin{equation}
p^*= \mathop{\arg\,\max}\limits_{p\in\mathcal{C}}H(p)
\end{equation}
$$</div>
<h3>指数形式</h3>
<p>经过上节的分析其实可以知道最大熵模型的目的就是要找到一个模型
<span class="math">\(p^*\in\mathcal{C}\)</span>使得<span class="math">\(H(p)\)</span>最大。这其实就是一个有约束条件下的最优化问题，可
以用<a href="https://en.wikipedia.org/wiki/Lagrange_multiplier" title="拉格朗日数乘">拉格朗日乘数法</a>来解，原始优化问题形式如下：
</p>
<div class="math">$$
\begin{align*}
&amp; max_p &amp;&amp; H(p) \\
&amp; s.t. &amp;&amp; p(y|x) \leq 0\text{ for all }x,y.\\
&amp;&amp;&amp; \sum_yp(y|x)=1\text{ for all }x. \\
&amp;&amp;&amp; \sum_{x,y}\tilde{p}(x)p(y|x)f(x,y)=\sum_{x,y}\tilde{p}(x,y)f(x,y)\text{ for }
i\in\left\{1,2,...,n\right\}. 
\end{align*}
$$</div>
<p>
前两个约束保证模型是一个条件概率分布，第三个约束值得是模型需要满足的统计量。该
问题等价于在相同约束下最小化<span class="math">\(-H(p)\)</span>：
</p>
<div class="math">$$\begin{equation}\begin{split}
&amp; min_p &amp;&amp; -H(p) \\
&amp; s.t. &amp;&amp; p(y|x) \leq 0\text{ for all }x,y.\\
&amp;&amp;&amp; \sum_yp(y|x)=1\text{ for all }x.\\
&amp;&amp;&amp; \sum_{x,y}\tilde{p}(x)p(y|x)f(x,y)=\sum_{x,y}\tilde{p}(x,y)f(x,y)\text{ for }
i\in\left\{1,2,...,n\right\}.
\end{split}
\label{eq:primal}
\end{equation}$$</div>
<p>
用拉格朗日乘数法将有约束问题转换成无约束问题，拉格朗日方程如下：
</p>
<div class="math">$$\begin{equation}\begin{split}
\mathcal{L}(p,\Lambda,\gamma)=&amp;\sum_{x,y}\tilde{p}(x)p(y|x)\log p(y|x)\\
&amp;+\sum_i^n\lambda_i\left(sum_{x,y}\tilde{p}(x,y)f_i(x,y)-\sum_{x,y}\tilde{p}(x)p(y|x)f_i(x,y)\right)\\
&amp;+\gamma(\sum_yp(y|x) - 1)
\end{split}
\label{eq:lagrangian}
\end{equation}$$</div>
<p>
对于<span class="math">\(\ref{eq:lagrangian}\)</span>这个拉格朗日方程原问题如下：
</p>
<div class="math">$$\begin{equation}
\min_w\max_{\Lambda,\gamma}\mathcal{L}(p,\Lambda,\gamma)
\end{equation}$$</div>
<p>
对偶问题为：
</p>
<div class="math">$$\begin{equation}
\max_{\Lambda,\gamma}\min_w\mathcal{L}(p,\Lambda,\gamma)
\label{eq:dual}
\end{equation}$$</div>
<p>
由于<span class="math">\(p\)</span>是一个凸函数，并且两个约束都和<span class="math">\(p\)</span>呈线性关系，所以原始问题的解和对偶问题
的解是等价的，下面求如何最大化对偶问题<span class="math">\(\ref{eq:dual}。首先固定\)</span>Lambda<span class="math">\(和
$\gamma\)</span>求<span class="math">\(\mathcal{L}(p,\Lambda,\gamma)\)</span>的最小值，将<span class="math">\(\ref{eq:lagrangian}\)</span>对
<span class="math">\(p\)</span>求导，另求导结果等于0，得到：
</p>
<div class="math">$$
\frac{\partial \mathcal{L}(p,\Lambda,\gamma)}{\partial
p(y|x)}=\tilde{p}(x)\left(1+\log
p(y|x)\right)-\sum_i\lambda_i\tilde{p}(x)f_i(x,y) + \gamma=0
$$</div>
<p>
可以求得最优的<span class="math">\(p(y|x)\)</span>具有如下形式：
</p>
<div class="math">$$\begin{equation}\begin{split}
&amp;\log p^*(y|x)=\sum_i\lambda_if_i(x,y)-\frac{\gamma}{\tilde{p}(x)}-1\\
\Rightarrow&amp;p*(y|x)=\exp\left(\sum_i\lambda_if_i(x,y)\right)\exp\left(-\frac{\gamma)}{\tilde{p}(x)}-1\right)
\end{split}
\label{eq:optimalp}
\end{equation}$$</div>
<p>
这样我们就找到了<span class="math">\(p^*\)</span>的最优化形式，现在的目标就是要去求解<span class="math">\(\gamma^*\)</span>和
<span class="math">\(\Lambda^*\)</span>。注意到<span class="math">\(\ref{eq:optimalp}\)</span>的第二项实际上对应的就是原始束问题
<span class="math">\(\ref{eq:primal}\)</span>的第二个约束，可以把<span class="math">\(\ref{eq:optimalp}\)</span>写成如下形式：
</p>
<div class="math">$$\begin{equation}\begin{split}
p*(y|x)&amp;=\frac{p^*(y|x)}{\sum_yp^*(y|x)}\\
&amp;=\frac{\exp\left(\sum_i\lambda_if_i(x,y)\right)\exp\left(-\frac{\gamma)}{\tilde{p}(x)}-1\right)}{\sum_y{\exp\left(\sum_i\lambda_if_i(x,y)\right)\exp\left(-\frac{\gamma)}{\tilde{p}(x)}-1\right)}}\\
&amp;=\frac{\exp\left(\sum_i\lambda_if_i(x,y)\right)}{Z(x)}
\end{split}
\label{eq:optimalpnew}
\end{equation}$$</div>
<p>
其中
</p>
<div class="math">$$\begin{equation}
Z(x)=\sum_y\exp\left(\sum_i\lambda_if_i(x,y)\right)
\end{equation}$$</div>
<p>
<span class="math">\(\ref{eq:optimalpnew}\)</span>就是最终<span class="math">\(p^*\)</span>的参数形式，并且满足<span class="math">\(\ref{eq:primal}\)</span>的第二
个约束，此时相当于我们已经找到了最优的<span class="math">\(p^*\)</span>和<span class="math">\(\gamma^*\)</span>，<span class="math">\(p^*\)</span>带入
拉格朗日方程<span class="math">\(\ref{eq:lagrangian}\)</span>中，得到对偶函数：
</p>
<div class="math">$$ \begin{align}
\Psi(\Lambda)&amp;=\mathcal{L}(p^*,\Lambda,\gamma^*)\nonumber\\
&amp;=\sum_{x,y}\tilde{p}(x)p^*(y|x)\log p^*(y|x)+\sum_i^n\lambda_i\left(\sum_{x,y}\tilde{p}(x,y)f_i(x,y)-\sum_{x,y}\tilde{p}(x)p^*(y|x)f_i(x,y)\right)\nonumber\\
&amp;=\sum_{x,y}\tilde{p}(x,y)\sum_i\lambda_i f_i(x,y)+\sum_{x,y}\tilde{p}(x)p^*(y|x)\left(\log p^*(y|x)-\sum_i\lambda_i f_i(x,y)\right)\nonumber\\
&amp;=\sum_{x,y}\tilde{p}(x,y)\sum_i\lambda_i f_i(x,y)-\sum_{x,y}\tilde{p}(x)p^*(y|x)\log Z(x)\nonumber\\
&amp;=\sum_{x,y}\tilde{p}(x,y)\sum_i\lambda_i f_i(x,y)-\sum_{x}\tilde{p}(x)\log Z(x)
\label{eq:optimallambda}
\end{align} $$</div>
<p>
所以现在的对偶问题<span class="math">\(\ref{eq:dual}\)</span>相当于是要优化如下目标：
</p>
<div class="math">$$ \begin{align}
\max_{\Lambda}\Psi(\Lambda)=\max_{\Lambda}\left[\sum_{x,y}\tilde{p}(x,y)\sum_i\lambda_i f_i(x,y)-\sum_{x}\tilde{p}(x)\log Z(x)\right]
\end{align} $$</div>
<p>
最优的<span class="math">\(\Lambda^*\)</span>需要满足：
</p>
<div class="math">$$ \begin{align}
\DeclareMathOperator*{\argmax}{arg\,max}
\Lambda^*=\argmax_{\Lambda}\Psi(\Lambda)=\argmax_{\Lambda}\left[\sum_{x,y}\tilde{p}(x,y)\sum_i\lambda_i f_i(x,y)-\sum_{x}\tilde{p}(x)\log Z(x)\right]
\end{align} $$</div>
<h3>最大似然</h3>
<p>已知训练数据的经验分布<span class="math">\(\tilde{p}(x,y)\)</span>，模型<span class="math">\(p(y|x)\)</span>的对数似然函数表示为：
</p>
<div class="math">$$\begin{align}
L_{\tilde{p}}(p) &amp;\equiv \log\Pi_{x,y}p(y|x)^{\tilde{p}(x,y)}=\sum_{x,y}\tilde{p}(x,y)\log p(y|x) \nonumber \\
&amp;=\sum_{x,y}\tilde{p}(x,y)\sum_i\lambda_i f_i(x,y)-\sum_{x,y}\tilde{p}(x,y)\log Z(x) \nonumber \\G
&amp;=\sum_{x,y}\tilde{p}(x,y)\sum_i\lambda_i f_i(x,y)-\sum_{x,y}\tilde{p}(x)\log Z(x)
\label{eq:likehood}
\end{align}$$</div>
<p>
可以看出对偶函数<span class="math">\(\Psi(\Lambda)\)</span>形式<span class="math">\(\ref{eq:optimallambda}\)</span>和模型<span class="math">\(p\)</span>的对数似然
结果是等价的。所以整个对偶问题的求解找到的熵最大的模型<span class="math">\(p*\)</span>其实也最大化了模型在&nbsp;训练样本上的似然。</p>
<h3>参数求解</h3>
<p>对于一般的问题一般无法用数学分析的方法求解出最大化<span class="math">\(\Psi(\Lambda)\)</span>的<span class="math">\(\Lambda^*\)</span>
，一般需要用数值方法来求解。因为<span class="math">\(\Psi(\Lambda)\)</span>是一个光滑的凸函数，所以有很多
方法都可以用来求<span class="math">\(\Lambda^*\)</span>，例如梯度下降、共轭梯度、坐标上升等方法。这里介绍
的是专门针对最大熵问题设计的<code>改进的尺度迭代算法（improved iterative scaling,
IIS）</code>，该算法要求所有的特征函数<span class="math">\(f_i(x,y)\)</span>必须非负。
<img alt="IIS算法" src="https://wugh.github.io/images/ML/iis.png" />
算法的关键在于求解第3步的<span class="math">\(\Delta\lambda_i\)</span>，如果这时候<span class="math">\(f^\#(x,y)\)</span>（表示某个样
本<span class="math">\(x,y\)</span>激活的特征函数个数）对于所有的<span class="math">\(x,y\)</span>都一样，即<span class="math">\(f^\#(x,y)\)</span>是一个常数<span class="math">\(M\)</span>，
那么<span class="math">\(\Delta\lambda_i\)</span>可以按下面式子求解
</p>
<div class="math">$$
\Delta\lambda_i = \frac{1}{M}\log\frac{\tilde{p}(f_i)}{p_\Lambda(f_i)}
$$</div>
<p>
如果<span class="math">\(f^\#(x,y)\)</span>不是一个常数，那么<span class="math">\(\Delta\lambda_i\)</span>需要通过数值方法计算。一个简
单快速的方法是通过<a href="https://en.wikipedia.org/wiki/Newton%27s_method" title="牛顿法">牛顿法</a>来求解，相当于这时候的目标函数
<span class="math">\(g(\Delta\lambda_i)\)</span>就是算法第3步那个方程把右边那一项移到左边的函数，现在的目
标就是要求<span class="math">\(g(\Delta\lambda_i)=0\)</span>的<span class="math">\(\Delta\lambda_i\)</span>，可以按下面的更新公式求
</p>
<div class="math">$$\begin{equation}
\Delta\lambda_i^{n+1}=\Delta\lambda_i^n-\frac{g(\Delta\lambda_i^n)}{g'(\Delta\lambda_i^n)}
\end{equation}$$</div>
<p>
通过选取适当的初始<span class="math">\(\Delta\lambda_i^0\)</span>，由于<span class="math">\(g(\Delta\lambda_i)=0\)</span>有单根，牛顿&nbsp;法可以快速收敛。</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script> </div>
	    </article>

	    <!--
	    in case any image breaks the theme
	    i was going to use :after but it didn't quite work for me, maybe next time-->
	    <div class="clearfix"></div>



	</div>
    </div>
</div>
<div class="row">
    <div class="span1 metadata alpha">
	<aside>
	    <div class="entry-date">
		<div class="month-day">
		    <time pubdate datetime="2014-04-25T19:19:36+08:00" title="Apr 25, 14">
			Apr.<span class="day">25</span>
			<div class="year">14</div>
		    </time>
		</div>

	    </div>

	</aside> 

    </div>
    <div class="span7">
	<div class="entry-container ">

	    <article  class="entry hentry" >
		<header>
		    <a href="/posts/2014/04/an-introduction-to-mdp/" rel="bookmark" title="permalink for MDP入门" ><h2 class="entry-title"><span class="caps">MDP</span>入门</h2></a>
		    <div class="author-details vcard">

			by <a  class="url fn" href="/author/guohua-wu.html">Guohua Wu</a>  file under <a href="/category/machine-learning.html">Machine Learning</a> with tags 			<a href="https://wugh.github.io/tag/mdp.html" title="Browse tag: MDP" rel="tag">MDP</a>		    </div>
		</header>
		<div class="entry-content">
		<hr />
<h3>介绍</h3>
<p><span class="caps">MDP</span>（Markov Decision
Process）由5元组构成<span class="math">\(MDP(S,A,{P_{sa}},\gamma,R)\)</span>，具体的&nbsp;参数介绍如下：</p>
<ul>
<li><span class="math">\(S\)</span>：状态集合</li>
<li><span class="math">\(A\)</span>：动作集合</li>
<li><span class="math">\(P_{sa}\)</span>：状态转移概率分布，<span class="math">\(P_{sa}(s')\)</span>表示在<span class="math">\(s\)</span>状态下采取
  <span class="math">\(s\)</span>动作，转移到<span class="math">\(s'\)</span>的概率，<span class="math">\(P_{sa}(s')\geq0\)</span></li>
<li><span class="math">\(\gamma\)</span>：折扣系数取值范围<span class="math">\(0\leq\gamma\le1\)</span></li>
<li><span class="math">\(R\)</span>：回报函数，<span class="math">\(R:S\mapsto&nbsp;\mathbb{R}\)</span></li>
</ul>
<p>下面举一个例子来说明<span class="caps">MDP</span>的参数，假设一个机器人在如所描述的
网格中走动，灰色代表障碍物，当机器人走到<span class="math">\((4,3)\)</span>位置将获得<span class="math">\(+1\)</span>的回报，走到
<span class="math">\((4,2)\)</span>位置回报为<span class="math">\(-1\)</span>。</p>
<p><img alt="MDP简单例子" src="https://wugh.github.io/images/ML/simple-pomdp.png" />
<img alt="动作执行受噪声干扰" src="https://wugh.github.io/images/ML/noisy.png" /></p>
<p>如果用<span class="caps">MDP</span>来描述这个例子，那么<span class="math">\(S\)</span>就有<span class="math">\(11\)</span>中取值，机器人可能处在除了障碍物的其他
位置；<span class="math">\(A\)</span>就有<span class="math">\(4\)</span>种取值，机器人可以往<span class="math">\({N,S,E,W}\)</span>四个方向走；假设现在处于<span class="math">\([3,1]\)</span>
位置，采取动作<span class="math">\(N\)</span>（虽然命令机器人向前走，但是由于噪声的影响，可能机器人会向左
或者向右走，如），假设<span class="math">\(P_{[3,1]N}\)</span>分布如下
<span class="math">\(P_{[3,1]N}([3,2])=0.8\)</span>，<span class="math">\(P_{[3,1]N}([2,1])=0.1\)</span>，<span class="math">\(P_{[3,1]N}([4,1])=0.1\)</span>，
<span class="math">\(P_{[3,1]N}([1,1])=0\)</span>等（除了相邻的位置，其他位置都无法到达，所以为<span class="math">\(0\)</span>）；回报
函数<span class="math">\(R\)</span>，<span class="math">\(R([4,2])=-1\)</span>，<span class="math">\(R([4,3])=+1\)</span>，对于其他位置而言<span class="math">\(R(s)=-0.02\)</span>，因为当机器&nbsp;人每走动一步都需要消耗电量，所以对于中间状态回报是一个比较小的负数。</p>
<p>对于的描述，状态的变化过程如下描述，假设<span class="math">\(0\)</span>时刻状态是<span class="math">\(s_0\)</span>
，然后选择一个动作<span class="math">\(a_0\)</span>，根据<span class="math">\(s\_1 \thicksim P_{s_0a_0}\)</span>分布选择目标状态<span class="math">\(s_1\)</span>，再选择
动作<span class="math">\(a_1\)</span>，根据<span class="math">\(s\_2 \thicksim P_{s_1a_1}\)</span>选择目标状态<span class="math">\(s_2\)</span>，依此类推状态序列。
对于这个状态变化序列，可以计算总的回报值（Total&nbsp;Payoff）。</p>
<p>初始状态是<span class="math">\(s_0\)</span>的总回报定义如下，<span class="math">\(0\leq \gamma \le 1\)</span>：
</p>
<div class="math">$$R(s_0) + \gamma R(s_1) + \gamma^2 R(s_2) + \dots
    \label{eq:totalpayoff}$$</div>
<p>
总的回报是当前的回报，加上未来的回报，但是距离当前越远回报值权重越小，为了使得
总的回报值最大，我们需要选择一组最优动作序列<span class="math">\((a_0,a_1,\dots)\)</span>使得总回报的期望最大：</p>
<div class="math">$$E[R(s_0) + \gamma R(s_1) + \gamma^2 R(s_2) + \dots]
  \label{eq:expectedpayoff}$$</div>
<p>最后还需要引入一个定义<span class="math">\(\pi\)</span>：策略<span class="math">\(\pi\)</span>指的是，在给定状态选择一个动作，映射关系
为：<span class="math">\(S\mapsto A\)</span>。</p>
<p>所以选择一个最优的动作序列，就是说要找到一个最优的<span class="math">\(\pi\)</span>，对于
能够求解出如的最优<span class="math">\(\pi\)</span>，下面的章节会解释如何求解<span class="math">\(\pi\)</span>。</p>
<h3><span class="caps">MDP</span>求解</h3>
<p>本节我们需要定义几个辅助变量：<span class="math">\(V^{\pi}\)</span>，<span class="math">\(V^*\)</span>和<span class="math">\(\pi^*\)</span>，下面将逐步介绍&nbsp;定义。</p>
<h4><span class="math">\(V^\pi\)</span></h4>
<p>对于任意<span class="math">\(\pi\)</span>都可以定义一个值函数<span class="math">\(V^{\pi}\)</span>（映射关系是<span class="math">\(S\mapsto \mathbb{R}\)</span>）
，<span class="math">\(V^{\pi}\)</span>指的是从状态<span class="math">\(s\)</span>开始并执行策略<span class="math">\(\pi\)</span>之后所得到的总回报值的期望：</p>
<div class="math">$$V^{\pi}=E\Big[R(s_0) + \gamma R(s_1) + \dots|\pi, s_0=s\Big]
    \label{eq:vpi}$$</div>
<p>下面是一个具体的例子，如是一个<span class="math">\(\pi\)</span>，是与之
对应的<span class="math">\(V^\pi\)</span>，实际上这个策略<span class="math">\(\pi\)</span>并不是非常好，因为对于很多状态执行该策略
后趋向于走到<span class="math">\(-1\)</span>位置而不是<span class="math">\(+1\)</span>位置。中下面两行执行的动作
使得机器人偏向走到<span class="math">\(-1\)</span>位置，所以他们的总回报的期望值是负数，对于最上面一行偏向
于走到<span class="math">\(+1\)</span>位置，所以总回报都是正的。所以对于下两行的位置这个策略非常差，但是&nbsp;对于最上面那行这个策略就显得不错。</p>
<p><img alt="其中一个pi" src="https://wugh.github.io/images/ML/one-pi.png" />
<img alt="pi对应的V" src="https://wugh.github.io/images/ML/v-pi.png" /></p>
<p>下面要对<span class="math">\(V^\pi\)</span>做一个推导使得<span class="math">\(V\pi\)</span>更容易计算，这里假设当前状态<span class="math">\(s\)</span>会转移到状态
<span class="math">\(s'\)</span>。中的<span class="math">\(P_{s\pi(s)}(s')\)</span>描述的是<span class="math">\(s\)</span>状态下采取一个动作
（这个动作由<span class="math">\(\pi(s)\)</span>来确定）转移到<span class="math">\(s'\)</span>状态的概率分布，因此式子中的求和描述的就
是一个求期望的过程，总回报值的期望是当前回报加上未来回报值的期望，
也称作贝尔曼方程（Bellman’s&nbsp;Equations）。</p>
<div class="math">$$\begin{align}
  V^\pi(s) &amp;= E\Big[R(s_0) + \gamma \Big(R(s_1) + \gamma R(s_2) + \dots\Big)\Big|\pi,s_0=s\Big] \cr
  &amp;= R(s) + \gamma \sum_{s'}{P_{s\pi(s)}(s')V^\pi(s')}
\label{eq:bellman}
\end{align}$$</div>
<p>对于的例子，如果针对每个状态都写出方程，
那么就可以得到<span class="math">\(11\)</span>个线性方程组，并且有<span class="math">\(11\)</span>个未知数（每个状态都有一个<span class="math">\(V^pi(s)\)</span>），
可以通过求解这个方程组得到<span class="math">\(V^\pi\)</span>。按照的策略，我们可以计算
<span class="math">\([3,1]\)</span>位置的<span class="math">\(V^\pi\)</span>： </p>
<div class="math">$$\begin{split}
  V^\pi([3,1]) = &amp;R([3,1]) + \cr
  &amp; \gamma[0.8V\pi([3,2]) + 0.1V\pi([4,1]) + 0.1V\pi([2,1])]
\end{split}$$</div>
<h4><span class="math">\(V^*\)</span> 和 <span class="math">\(\pi^*\)</span></h4>
<p>最优值函数<span class="math">\(V^*(s)\)</span>定义如下：</p>
<p><span class="math">\(V^*(s)\)</span>是最优值函数，值得是找到一个<span class="math">\(\pi\)</span>使得对于所有的状态<span class="math">\(V^\pi(s)\)</span>最大。</p>
<div class="math">\begin{equation}
V^*(s) = \max_x V^\pi(s)
    \label{eq:vstar}
\end{equation}</div>
<p>集合和可以得到<span class="math">\(V^*\)</span>的贝尔曼方程：</p>
<div class="math">\begin{equation}
V^*(s) = R(s) + \max_a \gamma \sum_{s'}{P_{sa}(s')V^*(s')} 
  \label{eq:vstarbellman}
\end{equation}</div>
<p>根据最优值函数的贝尔曼方程，把中的常数项<span class="math">\(R(s)\)</span>和
常数系数<span class="math">\(\gamma\)</span>去掉（处于状态<span class="math">\(s\)</span>时，对于所有的<span class="math">\(a\)</span>这两个系数都相等），
就可以得到最优策略<span class="math">\(\pi^*(s)\)</span>的求解公式：</p>
<div class="math">\begin{equation}
\DeclareMathOperator*{\argmax}{arg\,max}
\pi^*(s) = \argmax_a \sum_{s'}{P_{sa}(s')V^*(s')} 
  \label{eq:bestpi}
\end{equation}</div>
<p>由可以看出<span class="math">\(\pi^*(s)\)</span>其实依赖于<span class="math">\(V^*(s)\)</span>，所以现在的主要目标是要想办法求解
<span class="math">\(V^*(s)\)</span>。根据的定义，最直接的方法就是穷举所有的<span class="math">\(\pi\)</span>，但是穷举的情况会非常多
，例如有<span class="math">\(11\)</span>个状态，<span class="math">\(4\)</span>个动作那么就有<span class="math">\(4^{11}\)</span>种组合，搜索空间呈指数增长，不大
合理，下面将介绍值迭代（Value Iteration）和策略迭代（Policy Iteration）方法来
求解<span class="math">\(V^*(s)\)</span>。</p>
<p>算法所描述的是值迭代的过程，初始化时对于所有的<span class="math">\(s\)</span>对应的
<span class="math">\(V(s)\)</span>为<span class="math">\(0\)</span>，接着对于每个<span class="math">\(V(s)\)</span>，这里的<span class="math">\(V(s)\)</span>有两种更新方式。</p>
<p><img alt="值迭代" src="https://wugh.github.io/images/ML/mdp-vi.png" /></p>
<p>第一种是对于所有的状态计算出式子右边的部分，然后同时更新所有的<span class="math">\(V(s)\)</span>,这种称作
同步更新（Synchronous Update）；另一种叫做异步更新（Asynchronous
Update），假设我们按照固定的状态顺序更新<span class="math">\(V(s)\)</span>，那么首先会更新第1个状态
的<span class="math">\(V(s)\)</span>，接着是第2个状态的<span class="math">\(V(s)\)</span>、第3个状态的<span class="math">\(V(s)\)</span>、第4个状态的<span class="math">\(V(s)\)</span>
，如果在更新第5个状态的<span class="math">\(V(s)\)</span>用到的<span class="math">\(V(s')\)</span>恰好是第1、2、3、4状态的，
那么我们使用的<span class="math">\(V(s')\)</span>是前面几次迭代更新的版本。两种方法中异步更新会
收敛地稍微快一点，值迭代会使得<span class="math">\(V(s)\)</span>不断地向<span class="math">\(V^*(s)\)</span>接近，如
是最后求解出来的<span class="math">\(V^*(s)\)</span>。</p>
<p><img alt="左图是\(V^*\)且\gamma=.99，右图是对应的\(\pi^*\)" src="https://wugh.github.io/images/ML/bestv-and-pi.png" /></p>
<p>求解出<span class="math">\(V^*(s)\)</span>之后，根据就可以计算<span class="math">\(\pi^*(s)\)</span>，
下面举一个例子计算<span class="math">\(\pi([3,1])\)</span>的最优策略，结合，可以
计算出采取各个动作的未来总回报的期望，假设机器人碰到墙壁之后会回到
原来的位置，所以机器人向<span class="math">\(E\)</span>走的时候有<span class="math">\(0.1\)</span>的可能性会碰到墙壁然后又
返回到<span class="math">\([3,1]\)</span>位置。 </p>
<div class="math">\begin{aligned}
    E: &amp; \sum_{s'}{P_{sa}(s')V^*(s')} = 0.8*0.75 + 0.1*0.69 + 0.1*0.71 = 0.74\cr
    N: &amp; \sum_{s'}{P_{sa}(s')V^*(s')} = 0.8*0.69 + 0.1*0.75 + 0.1*0.49 = 0.676\cr
    W: &amp; \sum_{s'}{P_{sa}(s')V^*(s')} = 0.8*0.49 + 0.1*0.69 + 0.1*0.71 = 0.532\cr
    S: &amp; \sum_{s'}{P_{sa}(s')V^*(s')} = 0.8*0.71 + 0.1*0.75 + 0.1*0.49 = 0.692
\end{aligned}</div>
<p>对比<span class="math">\(4\)</span>个方向的未来总回报的期望值之后，发现采取<span class="math">\(E\)</span>动作之后得到的值最大，
所以在<span class="math">\([3,1]\)</span>位置会采取动作<span class="math">\(E\)</span>。对每个状态都计算最优动作之后就可以得到如&nbsp;所示的结果。</p>
<p>描述完值迭代之后，下面简单描述一下策略迭代求解<span class="math">\(V^*(s)\)</span>，策略迭代会使得最后
<span class="math">\(V(s)\)</span>趋近于<span class="math">\(V^*(s)\)</span>并且<span class="math">\(\pi(s)\)</span>趋近于<span class="math">\(\pi^*(s)\)</span>。</p>
<p><img alt="策略迭代" src="https://wugh.github.io/images/ML/mdp-pi.png" /></p>
<p>当状态数量少的时候可以采用策略迭代，因为这时候求解贝尔曼方程比较快速，但是当
状态数非常多，例如有100万个状态，那么求解贝尔曼方程的代价可能会太大，就应该&nbsp;考虑使用值迭代。</p>
<p>这里还需要讨论一下如何求解<span class="math">\(P_{sa}\)</span>，一般来说可以用最大似然估计来估计。</p>
<div class="math">\begin{equation}
\begin{split}
    P_{sa}(s') &amp;= \frac{\text{在}s\text{状态下采取动作a到达状态}s'\text{的次数}}
    {\text{在}s\text{状态下采取动作}a\text{的次数}} \cr
    &amp;\Big(\text{如果得到}\frac{0}{0}\text{的情况就用}\frac{1}{|s|}\text{替换}\Big)
  \end{split}
  \label{eq:psa}
\end{equation}</div>
<h4>求解过程总结</h4>
<p>把上文提到的求解<span class="math">\(V^*(s)\)</span>、<span class="math">\(\pi^*(s)\)</span>和<span class="math">\(P_{sa}\)</span>的方法结合起来就可以构成一个完整
的求解<span class="caps">MDP</span>的方法。首先采取策略<span class="math">\(\pi\)</span>之后可以观测到一些状态转移的数据，用这些
数据来重新估计<span class="math">\(P_{sa}\)</span>，接着用值迭代的方式来求解当前<span class="math">\(\pi\)</span>和<span class="math">\(P_{sa}\)</span>前提
下的<span class="math">\(V^*(s)\)</span>（值迭代的初始<span class="math">\(V(s)\)</span>可以使用上一轮迭代的<span class="math">\(V^*(s)\)</span>），
最后再利用这个<span class="math">\(V^*(s)\)</span>来更新<span class="math">\(\pi\)</span>。
<img alt="整个过程" src="https://wugh.github.io/images/ML/put-together.png" /></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script> </div>
	    </article>

	    <!--
	    in case any image breaks the theme
	    i was going to use :after but it didn't quite work for me, maybe next time-->
	    <div class="clearfix"></div>



	</div>
    </div>
</div>



		    </div>
		</div>
<!-- Sidebar -->
<aside class="span3 remove-bs-margin hidden-phone hidden-tablet">

    <div class="widget-external-links widget">
	<h3 class="widget-header">External Links</h3>
	<div class="widget-content">
	    <ul class="widget-list">
		<li class="widget-list-item"><a href="http://getpelican.com/">Pelican</a></li>		<li class="widget-list-item"><a href="http://python.org/">Python.org</a></li>		<li class="widget-list-item"><a href="http://jinja.pocoo.org/">Jinja2</a></li> 	    </ul>
	</div>
    </div>
    <div class="widget-external-links widget">
        <h3 class="widget-header">Recent Articles</h3>
	<div class="widget-content">
	    <ul class="widget-list">
		<li class="widget-list-item"><a href="https://wugh.github.io/posts/2014/11/maxent/" title="Read: 最大熵">最大熵</a></li>
		<li class="widget-list-item"><a href="https://wugh.github.io/posts/2014/04/an-introduction-to-mdp/" title="Read: MDP入门"><span class="caps">MDP</span>入门</a></li>
	    </ul>
	</div>
    </div>
    <div class="widget-archive-category widget">
	<h3 class="widget-header">Category</h3>
	<div class="widget-content">
	    <ul class="widget-list">
		<li class="widget-list-item"><a href="https://wugh.github.io/category/linux.html">Linux.<span>7</span></a></li>

		<li class="widget-list-item"><a href="https://wugh.github.io/category/machine-learning.html">Machine Learning.<span>2</span></a></li>

		<li class="widget-list-item"><a href="https://wugh.github.io/category/nlp.html">NLP.<span>1</span></a></li>

		<li class="widget-list-item"><a href="https://wugh.github.io/category/web.html">Web.<span>2</span></a></li>

	    </ul>
	</div>
    </div>
    <div class="widget">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- dgzen he -->
	<ins class="adsbygoogle"
	    style="display:inline-block;width:300px;height:600px"
	    data-ad-client="ca-pub-4442880234515975"
	    data-ad-slot="1240455063"></ins>
	<script>
	    (adsbygoogle = window.adsbygoogle || []).push({});
	</script>
    </script>
</div>
		</aside>
	    </div>
	    <!--footer-->
	    <div class="row">
		<div class="span12">
		    <footer>
			<p>Powered by <a href="http://getpelican.org">Pelican</a>.</p>
			<p><a href="">Nuja theme</a> designed by <a rel="bookmark" href="http://dgzen.pw">DGZen</a>.</p>
		    </footer>
		</div>
	    </div>
	</div>


    </body>
</html>